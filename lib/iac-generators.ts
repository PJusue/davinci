import { ParsedInfrastructure, GeneratedIaC, IaCFormat } from "@/types/infrastructure";

export class IaCGenerator {
  generateTerraform(parsed: ParsedInfrastructure): GeneratedIaC {
    let code = `# Terraform Configuration for ${parsed.provider.toUpperCase()}\n`;
    code += `# Generated by IaC Converter\n\n`;

    // Provider configuration
    code += `terraform {\n`;
    code += `  required_providers {\n`;

    switch (parsed.provider) {
      case "aws":
        code += `    aws = {\n`;
        code += `      source  = "hashicorp/aws"\n`;
        code += `      version = "~> 5.0"\n`;
        code += `    }\n`;
        break;
      case "azure":
        code += `    azurerm = {\n`;
        code += `      source  = "hashicorp/azurerm"\n`;
        code += `      version = "~> 3.0"\n`;
        code += `    }\n`;
        break;
      case "gcp":
        code += `    google = {\n`;
        code += `      source  = "hashicorp/google"\n`;
        code += `      version = "~> 5.0"\n`;
        code += `    }\n`;
        break;
    }

    code += `  }\n`;
    code += `}\n\n`;

    // Provider block
    code += `provider "${this.getProviderName(parsed.provider)}" {\n`;
    if (parsed.provider === "aws") {
      code += `  region = var.region\n`;
    } else if (parsed.provider === "azure") {
      code += `  features {}\n`;
    } else if (parsed.provider === "gcp") {
      code += `  project = var.project_id\n`;
      code += `  region  = var.region\n`;
    }
    code += `}\n\n`;

    // Variables
    code += `# Variables\n`;
    code += `variable "region" {\n`;
    code += `  description = "The region where resources will be created"\n`;
    code += `  type        = string\n`;
    code += `  default     = "${this.getDefaultRegion(parsed.provider)}"\n`;
    code += `}\n\n`;

    if (parsed.provider === "gcp") {
      code += `variable "project_id" {\n`;
      code += `  description = "GCP Project ID"\n`;
      code += `  type        = string\n`;
      code += `}\n\n`;
    }

    // Network resources
    if (parsed.network?.vpcs && parsed.network.vpcs.length > 0) {
      code += `# Network Configuration\n`;
      parsed.network.vpcs.forEach((vpc, index) => {
        code += this.generateTerraformVPC(vpc, parsed.provider, index);
      });
    }

    if (parsed.network?.subnets && parsed.network.subnets.length > 0) {
      parsed.network.subnets.forEach((subnet, index) => {
        code += this.generateTerraformSubnet(subnet, parsed.provider, index);
      });
    }

    if (parsed.network?.securityGroups && parsed.network.securityGroups.length > 0) {
      parsed.network.securityGroups.forEach((sg, index) => {
        code += this.generateTerraformSecurityGroup(sg, parsed.provider, index);
      });
    }

    // Resources
    if (parsed.resources && parsed.resources.length > 0) {
      code += `\n# Infrastructure Resources\n`;
      parsed.resources.forEach((resource) => {
        code += this.generateTerraformResource(resource, parsed.provider);
      });
    }

    // Outputs
    code += `\n# Outputs\n`;
    code += `output "deployment_info" {\n`;
    code += `  description = "Deployment information"\n`;
    code += `  value = {\n`;
    code += `    provider = "${parsed.provider}"\n`;
    code += `    region   = var.region\n`;
    code += `  }\n`;
    code += `}\n`;

    const resourceNames = parsed.resources.map((r) => r.name);

    return {
      format: "terraform",
      code,
      filename: "main.tf",
      resources: resourceNames,
    };
  }

  generateCloudFormation(parsed: ParsedInfrastructure): GeneratedIaC {
    if (parsed.provider !== "aws") {
      throw new Error("CloudFormation only supports AWS");
    }

    const template: any = {
      AWSTemplateFormatVersion: "2010-09-09",
      Description: "Infrastructure as Code generated by IaC Converter",
      Parameters: {
        Environment: {
          Type: "String",
          Default: "dev",
          Description: "Environment name",
        },
      },
      Resources: {},
      Outputs: {},
    };

    // Network resources
    if (parsed.network?.vpcs && parsed.network.vpcs.length > 0) {
      parsed.network.vpcs.forEach((vpc, index) => {
        const resourceName = `VPC${index === 0 ? "" : index}`;
        template.Resources[resourceName] = {
          Type: "AWS::EC2::VPC",
          Properties: {
            CidrBlock: vpc.cidr,
            EnableDnsHostnames: vpc.enableDnsHostnames ?? true,
            EnableDnsSupport: vpc.enableDnsSupport ?? true,
            Tags: [{ Key: "Name", Value: vpc.name || `VPC-${index}` }],
          },
        };
      });
    }

    if (parsed.network?.subnets && parsed.network.subnets.length > 0) {
      parsed.network.subnets.forEach((subnet, index) => {
        const resourceName = `Subnet${index}`;
        template.Resources[resourceName] = {
          Type: "AWS::EC2::Subnet",
          Properties: {
            VpcId: { Ref: "VPC" },
            CidrBlock: subnet.cidr,
            AvailabilityZone: subnet.availabilityZone || {
              "Fn::Select": [0, { "Fn::GetAZs": "" }],
            },
            MapPublicIpOnLaunch: subnet.public ?? false,
            Tags: [{ Key: "Name", Value: subnet.name || `Subnet-${index}` }],
          },
        };
      });
    }

    if (parsed.network?.securityGroups && parsed.network.securityGroups.length > 0) {
      parsed.network.securityGroups.forEach((sg, index) => {
        const resourceName = this.sanitizeCFName(sg.name) || `SecurityGroup${index}`;
        template.Resources[resourceName] = {
          Type: "AWS::EC2::SecurityGroup",
          Properties: {
            GroupDescription: sg.description || "Security group",
            VpcId: { Ref: "VPC" },
            SecurityGroupIngress:
              sg.ingress?.map((rule) => ({
                IpProtocol: rule.protocol,
                FromPort: rule.fromPort,
                ToPort: rule.toPort,
                CidrIp: rule.cidr || "0.0.0.0/0",
              })) || [],
            Tags: [{ Key: "Name", Value: sg.name }],
          },
        };
      });
    }

    // Infrastructure resources
    if (parsed.resources && parsed.resources.length > 0) {
      parsed.resources.forEach((resource) => {
        const cfResource = this.convertToCFResource(resource);
        if (cfResource) {
          template.Resources[this.sanitizeCFName(resource.name)] = cfResource;
        }
      });
    }

    // Outputs
    template.Outputs.StackInfo = {
      Description: "Stack deployment information",
      Value: { "Fn::Sub": "${AWS::StackName} deployed in ${AWS::Region}" },
    };

    const code = JSON.stringify(template, null, 2);
    const resourceNames = parsed.resources.map((r) => r.name);

    return {
      format: "cloudformation",
      code,
      filename: "template.json",
      resources: resourceNames,
    };
  }

  generatePulumiPython(parsed: ParsedInfrastructure): GeneratedIaC {
    let code = `"""Pulumi Infrastructure as Code\nGenerated by IaC Converter\n"""\n\n`;
    code += `import pulumi\n`;

    switch (parsed.provider) {
      case "aws":
        code += `import pulumi_aws as aws\n\n`;
        break;
      case "azure":
        code += `import pulumi_azure_native as azure\n\n`;
        break;
      case "gcp":
        code += `import pulumi_gcp as gcp\n\n`;
        break;
    }

    code += `# Configuration\n`;
    code += `config = pulumi.Config()\n`;
    code += `environment = config.get("environment") or "dev"\n\n`;

    // Network resources
    if (parsed.network?.vpcs && parsed.network.vpcs.length > 0) {
      code += `# Network Configuration\n`;
      parsed.network.vpcs.forEach((vpc, index) => {
        const varName = `vpc${index === 0 ? "" : index}`;
        code += `${varName} = aws.ec2.Vpc("${vpc.name}",\n`;
        code += `    cidr_block="${vpc.cidr}",\n`;
        code += `    enable_dns_hostnames=${vpc.enableDnsHostnames ?? true},\n`;
        code += `    enable_dns_support=${vpc.enableDnsSupport ?? true},\n`;
        code += `    tags={"Name": "${vpc.name}", "Environment": environment}\n`;
        code += `)\n\n`;
      });
    }

    if (parsed.network?.subnets && parsed.network.subnets.length > 0) {
      parsed.network.subnets.forEach((subnet, index) => {
        const varName = `subnet${index}`;
        code += `${varName} = aws.ec2.Subnet("${subnet.name}",\n`;
        code += `    vpc_id=vpc.id,\n`;
        code += `    cidr_block="${subnet.cidr}",\n`;
        code += `    map_public_ip_on_launch=${subnet.public ?? false},\n`;
        code += `    tags={"Name": "${subnet.name}", "Environment": environment}\n`;
        code += `)\n\n`;
      });
    }

    if (parsed.network?.securityGroups && parsed.network.securityGroups.length > 0) {
      parsed.network.securityGroups.forEach((sg, index) => {
        const varName = this.sanitizePythonName(sg.name);
        code += `${varName} = aws.ec2.SecurityGroup("${sg.name}",\n`;
        code += `    vpc_id=vpc.id,\n`;
        code += `    description="${sg.description}",\n`;
        if (sg.ingress && sg.ingress.length > 0) {
          code += `    ingress=[\n`;
          sg.ingress.forEach((rule) => {
            code += `        aws.ec2.SecurityGroupIngressArgs(\n`;
            code += `            protocol="${rule.protocol}",\n`;
            code += `            from_port=${rule.fromPort},\n`;
            code += `            to_port=${rule.toPort},\n`;
            code += `            cidr_blocks=["${rule.cidr || "0.0.0.0/0"}"],\n`;
            code += `        ),\n`;
          });
          code += `    ],\n`;
        }
        code += `    tags={"Name": "${sg.name}", "Environment": environment}\n`;
        code += `)\n\n`;
      });
    }

    // Resources
    if (parsed.resources && parsed.resources.length > 0) {
      code += `# Infrastructure Resources\n`;
      parsed.resources.forEach((resource) => {
        code += this.generatePulumiResource(resource, parsed.provider);
      });
    }

    // Exports
    code += `\n# Exports\n`;
    code += `pulumi.export("environment", environment)\n`;
    code += `pulumi.export("provider", "${parsed.provider}")\n`;

    const resourceNames = parsed.resources.map((r) => r.name);

    return {
      format: "pulumi-python",
      code,
      filename: "__main__.py",
      resources: resourceNames,
    };
  }

  generatePulumiTypeScript(parsed: ParsedInfrastructure): GeneratedIaC {
    let code = `// Pulumi Infrastructure as Code\n// Generated by IaC Converter\n\n`;
    code += `import * as pulumi from "@pulumi/pulumi";\n`;

    switch (parsed.provider) {
      case "aws":
        code += `import * as aws from "@pulumi/aws";\n\n`;
        break;
      case "azure":
        code += `import * as azure from "@pulumi/azure-native";\n\n`;
        break;
      case "gcp":
        code += `import * as gcp from "@pulumi/gcp";\n\n`;
        break;
    }

    code += `// Configuration\n`;
    code += `const config = new pulumi.Config();\n`;
    code += `const environment = config.get("environment") || "dev";\n\n`;

    // Network resources
    if (parsed.network?.vpcs && parsed.network.vpcs.length > 0) {
      code += `// Network Configuration\n`;
      parsed.network.vpcs.forEach((vpc, index) => {
        const varName = `vpc${index === 0 ? "" : index}`;
        code += `const ${varName} = new aws.ec2.Vpc("${vpc.name}", {\n`;
        code += `    cidrBlock: "${vpc.cidr}",\n`;
        code += `    enableDnsHostnames: ${vpc.enableDnsHostnames ?? true},\n`;
        code += `    enableDnsSupport: ${vpc.enableDnsSupport ?? true},\n`;
        code += `    tags: { Name: "${vpc.name}", Environment: environment },\n`;
        code += `});\n\n`;
      });
    }

    if (parsed.network?.subnets && parsed.network.subnets.length > 0) {
      parsed.network.subnets.forEach((subnet, index) => {
        const varName = `subnet${index}`;
        code += `const ${varName} = new aws.ec2.Subnet("${subnet.name}", {\n`;
        code += `    vpcId: vpc.id,\n`;
        code += `    cidrBlock: "${subnet.cidr}",\n`;
        code += `    mapPublicIpOnLaunch: ${subnet.public ?? false},\n`;
        code += `    tags: { Name: "${subnet.name}", Environment: environment },\n`;
        code += `});\n\n`;
      });
    }

    if (parsed.network?.securityGroups && parsed.network.securityGroups.length > 0) {
      parsed.network.securityGroups.forEach((sg, index) => {
        const varName = this.sanitizeTSName(sg.name);
        code += `const ${varName} = new aws.ec2.SecurityGroup("${sg.name}", {\n`;
        code += `    vpcId: vpc.id,\n`;
        code += `    description: "${sg.description}",\n`;
        if (sg.ingress && sg.ingress.length > 0) {
          code += `    ingress: [\n`;
          sg.ingress.forEach((rule) => {
            code += `        {\n`;
            code += `            protocol: "${rule.protocol}",\n`;
            code += `            fromPort: ${rule.fromPort},\n`;
            code += `            toPort: ${rule.toPort},\n`;
            code += `            cidrBlocks: ["${rule.cidr || "0.0.0.0/0"}"],\n`;
            code += `        },\n`;
          });
          code += `    ],\n`;
        }
        code += `    tags: { Name: "${sg.name}", Environment: environment },\n`;
        code += `});\n\n`;
      });
    }

    // Resources
    if (parsed.resources && parsed.resources.length > 0) {
      code += `// Infrastructure Resources\n`;
      parsed.resources.forEach((resource) => {
        code += this.generatePulumiTSResource(resource, parsed.provider);
      });
    }

    // Exports
    code += `\n// Exports\n`;
    code += `export const deploymentEnvironment = environment;\n`;
    code += `export const cloudProvider = "${parsed.provider}";\n`;

    const resourceNames = parsed.resources.map((r) => r.name);

    return {
      format: "pulumi-typescript",
      code,
      filename: "index.ts",
      resources: resourceNames,
    };
  }

  // Helper methods
  private getProviderName(provider: string): string {
    const map: Record<string, string> = {
      aws: "aws",
      azure: "azurerm",
      gcp: "google",
    };
    return map[provider] || provider;
  }

  private getDefaultRegion(provider: string): string {
    const map: Record<string, string> = {
      aws: "us-east-1",
      azure: "eastus",
      gcp: "us-central1",
    };
    return map[provider] || "us-east-1";
  }

  private generateTerraformVPC(vpc: any, provider: string, index: number): string {
    let code = `resource "${this.getProviderName(provider)}_vpc" "vpc${index === 0 ? "" : index}" {\n`;
    code += `  cidr_block           = "${vpc.cidr}"\n`;
    code += `  enable_dns_hostnames = ${vpc.enableDnsHostnames ?? true}\n`;
    code += `  enable_dns_support   = ${vpc.enableDnsSupport ?? true}\n\n`;
    code += `  tags = {\n`;
    code += `    Name = "${vpc.name}"\n`;
    code += `  }\n`;
    code += `}\n\n`;
    return code;
  }

  private generateTerraformSubnet(subnet: any, provider: string, index: number): string {
    let code = `resource "${this.getProviderName(provider)}_subnet" "subnet${index}" {\n`;
    code += `  vpc_id            = ${this.getProviderName(provider)}_vpc.vpc.id\n`;
    code += `  cidr_block        = "${subnet.cidr}"\n`;
    code += `  availability_zone = "${subnet.availabilityZone || "us-east-1a"}"\n\n`;
    code += `  tags = {\n`;
    code += `    Name = "${subnet.name}"\n`;
    code += `  }\n`;
    code += `}\n\n`;
    return code;
  }

  private generateTerraformSecurityGroup(sg: any, provider: string, index: number): string {
    const name = this.sanitizeTerraformName(sg.name) || `sg${index}`;
    let code = `resource "${this.getProviderName(provider)}_security_group" "${name}" {\n`;
    code += `  name        = "${sg.name}"\n`;
    code += `  description = "${sg.description}"\n`;
    code += `  vpc_id      = ${this.getProviderName(provider)}_vpc.vpc.id\n\n`;

    if (sg.ingress && sg.ingress.length > 0) {
      sg.ingress.forEach((rule: any) => {
        code += `  ingress {\n`;
        code += `    from_port   = ${rule.fromPort}\n`;
        code += `    to_port     = ${rule.toPort}\n`;
        code += `    protocol    = "${rule.protocol}"\n`;
        code += `    cidr_blocks = ["${rule.cidr || "0.0.0.0/0"}"]\n`;
        code += `  }\n\n`;
      });
    }

    code += `  tags = {\n`;
    code += `    Name = "${sg.name}"\n`;
    code += `  }\n`;
    code += `}\n\n`;
    return code;
  }

  private generateTerraformResource(resource: any, provider: string): string {
    const name = this.sanitizeTerraformName(resource.name);
    let code = `# ${resource.type}: ${resource.name}\n`;
    code += `resource "${resource.type}" "${name}" {\n`;

    Object.entries(resource.properties || {}).forEach(([key, value]) => {
      if (typeof value === "string") {
        code += `  ${key} = "${value}"\n`;
      } else if (typeof value === "boolean" || typeof value === "number") {
        code += `  ${key} = ${value}\n`;
      }
    });

    code += `}\n\n`;
    return code;
  }

  private generatePulumiResource(resource: any, provider: string): string {
    const varName = this.sanitizePythonName(resource.name);
    let code = `# ${resource.type}: ${resource.name}\n`;
    code += `${varName} = # TODO: Implement ${resource.type}\n\n`;
    return code;
  }

  private generatePulumiTSResource(resource: any, provider: string): string {
    const varName = this.sanitizeTSName(resource.name);
    let code = `// ${resource.type}: ${resource.name}\n`;
    code += `// const ${varName} = // TODO: Implement ${resource.type}\n\n`;
    return code;
  }

  private convertToCFResource(resource: any): any {
    // Basic conversion - can be enhanced based on resource type
    return {
      Type: resource.type,
      Properties: resource.properties || {},
    };
  }

  private sanitizeCFName(name: string): string {
    return name.replace(/[^a-zA-Z0-9]/g, "");
  }

  private sanitizeTerraformName(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9_]/g, "_");
  }

  private sanitizePythonName(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9_]/g, "_");
  }

  private sanitizeTSName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, "_");
  }
}

export function generateAllFormats(
  parsed: ParsedInfrastructure,
  formats: IaCFormat[]
): GeneratedIaC[] {
  const generator = new IaCGenerator();
  const results: GeneratedIaC[] = [];

  formats.forEach((format) => {
    try {
      switch (format) {
        case "terraform":
          results.push(generator.generateTerraform(parsed));
          break;
        case "cloudformation":
          if (parsed.provider === "aws") {
            results.push(generator.generateCloudFormation(parsed));
          }
          break;
        case "pulumi-python":
          results.push(generator.generatePulumiPython(parsed));
          break;
        case "pulumi-typescript":
          results.push(generator.generatePulumiTypeScript(parsed));
          break;
      }
    } catch (error) {
      console.error(`Error generating ${format}:`, error);
    }
  });

  return results;
}
